import chisel3._
import chisel3.util._
import chisel3.experimental.ChiselEnum
//suppose weight is already store in PIM's bank, generated by DRAM-PIM's write op



class ibex_core(Width: Int) extends Module {
  val io = IO(new Bundle {
    val CA = Input(UInt(7.W)) // LPDDR5 - CA - 7*2bit, suppose using the last 2 bit for op
    val DQ = Input(UInt(64.W)) // suppose bus_width = 64 bit
    val DQ_out = Output(UInt(64.W)) // output datapath, suppose bus_width = 64 bit

    val Input_GB_write_en = Output(Bool())
    val Input_GB_read_en = Output(Bool())
    val Input_GB_addr = Output(UInt(16.W))
    val Input_GB_data_write = Output(UInt(64.W))
    val Input_GB_data_read = Input(UInt(64.W))

    val PE_en = Output(Vec(8, Bool()))            
    val PE_mode = Output(Vec(8, Bool()))          
    val PE_addrA = Output(Vec(8, UInt(16.W)))      
    val PE_addrB = Output(Vec(8, UInt(16.W)))     
    val PE_length = Output(Vec(8, UInt(16.W)))    
    val PE_width = Output(Vec(8, UInt(16.W)))    



    val Output_GB_write_en = Output(Bool())
    val Output_GB_read_en = Output(Bool())
    val Output_GB_addr = Output(UInt(16.W))
    val Output_GB_data_write = Output(UInt(64.W))
    val Output_GB_data_read = Input(UInt(64.W))

  })

 // 初始化所有未定义的输出
  // 初始化所有输出为0或false
  io.DQ_out := 0.U                          // UInt(64.W) 初始化为 0
  io.Input_GB_write_en := false.B           // Bool 初始化为 false
  io.Input_GB_read_en := false.B            // Bool 初始化为 false
  io.Input_GB_addr := 0.U                    // UInt(16.W) 初始化为 0
  io.Input_GB_data_write := 0.U              // UInt(64.W) 初始化为 0
  io.PE_en := VecInit(Seq.fill(8)(false.B))               // 8个 PE 使能信号初始化为 false
  io.PE_mode := VecInit(Seq.fill(8)(false.B))             // 8个 PE 模式信号初始化为 false
  io.PE_addrA := VecInit(Seq.fill(8)(0.U(16.W)))          // 8个 PE 地址A信号初始化为 0
  io.PE_addrB := VecInit(Seq.fill(8)(0.U(16.W)))          // 8个 PE 地址B信号初始化为 0
  io.PE_length := VecInit(Seq.fill(8)(0.U(16.W)))         // 8个 PE 长度信号初始化为 0
  io.PE_width := VecInit(Seq.fill(8)(0.U(16.W)))          // 8个 PE 宽度信号初始化为 0
  io.Output_GB_write_en := false.B          // Bool 初始化为 false
  io.Output_GB_read_en := false.B           // Bool 初始化为 false
  io.Output_GB_addr := 0.U                   // UInt(16.W) 初始化为 0
  io.Output_GB_data_write := 0.U             // UInt(64.W) 初始化为 0



  //a simple op decoder for PIM_flow
  val addr = io.CA(6, 3) // addr = CA[6:3]
  val mode = io.CA(2)    // mode = CA[2]
  val op = io.CA(1, 0)   // op = CA[1:0]

  object States extends ChiselEnum {
    val Idel, Load_input, Compute_Dot, Compute_ADD, Read_Output = Value
  }

  val state = RegInit(States.Idel)

  val Input_addr = RegInit(0.U(16.W)) //sram address suppose 16bit
  val Input_length = RegInit(0.U(16.W))
  val vecA_addr = RegInit(0.U(16.W))
  val vecB_addr = RegInit(0.U(16.W))
  val vec_length = RegInit(0.U(16.W))
  val vec_width = RegInit(0.U(16.W))
  val Output_addr = RegInit(0.U(16.W))
  val Output_length = RegInit(0.U(16.W))
  val current_length = RegInit(0.U(16.W))

  //address = BaseAddress + Offset
  //TODO: baseAddress should be ready in pre_work
  //
  val Input_GB_baseAddress = RegInit(0.U(16.W))
  val Output_GB_baseAddress = RegInit(0.U(16.W))
  val PIM_bank_baseAddress = VecInit(Seq.fill(8)(0.U(16.W)))

  switch(state){
    is(States.Idel){
      when(op === "b00".U){
        state := States.Idel
      }
      .elsewhen(op === "b01".U){ // write to input_Global_Buffer, sram_addr is tranform by CA
        Input_addr := io.DQ(15,0)
        Input_length := io.DQ(31,16)
        state := States.Load_input
      }
      .elsewhen(op === "b10".U){ // do computing
          vecA_addr := io.DQ(15,0) 
          vecB_addr := io.DQ(31,16) 
          vec_length := io.DQ(47,32) //input_dim
          vec_width := io.DQ(63,48) //output_dim / tiling factor
        when(mode === 0.U){
          state := States.Compute_Dot
        }
        .elsewhen(mode === 1.U){
          state := States.Compute_ADD
        }
      }
      .elsewhen(op === "b11".U){ //read output_Global_buffer, sram_addr is tranform by io.DQ
        Output_addr := io.DQ(15,0)
        Output_length := io.DQ(31,16)
        state := States.Read_Output
      }

      io.Input_GB_write_en := 0.B
      io.Input_GB_read_en := 0.B
      io.Input_GB_addr := 0.U
      io.Input_GB_data_write := 0.U
      io.Output_GB_write_en := 0.B
      io.Output_GB_read_en := 0.B
      io.Output_GB_addr := 0.U
      io.DQ_out:= 0.U
    }
    is(States.Load_input){
      io.Input_GB_write_en := 1.B
      io.Input_GB_read_en := 0.B
      io.Input_GB_addr := Input_GB_baseAddress + Input_addr + current_length * 2.U
      io.Input_GB_data_write := io.DQ
      when(current_length + 4.U >= Input_length){
        current_length := 0.U
        state := States.Idel
      }
      .otherwise{
        current_length := current_length + 4.U
        state := States.Load_input
      }

      io.Output_GB_write_en := 0.B
      io.Output_GB_read_en := 0.B
      io.Output_GB_addr := 0.U
      io.DQ_out:= 0.U
      for(i <- 0 until 8){
        io.PE_en(i) := 0.B
        io.PE_mode(i) := 0.B
        io.PE_addrA(i) := 0.U
        io.PE_addrB(i) := 0.U
        io.PE_length(i) := 0.U
        io.PE_width(i) := 0.U
      }
    }
    is(States.Compute_Dot){
      for(i <- 0 until 8){
        io.PE_en(i) := 1.B
        io.PE_mode(i) := 0.B
        io.PE_addrA(i) := Input_GB_baseAddress + vecA_addr
        io.PE_addrB(i) := PIM_bank_baseAddress(i) + vecB_addr
        io.PE_length(i) := vec_length
        io.PE_width(i) := vec_width
      }
      state := States.Idel

      io.Input_GB_write_en := 0.B
      io.Input_GB_read_en := 0.B
      io.Input_GB_addr := 0.U
      io.Input_GB_data_write := 0.U

      io.Output_GB_write_en := 0.B
      io.Output_GB_read_en := 0.B
      io.Output_GB_addr := 0.U
      io.DQ_out:= 0.U
    }
    is(States.Compute_ADD){ // TODO: is compute by 8 PIM both????
      for(i <- 0 until 8){
        io.PE_en(i) := 1.B
        io.PE_mode(i) := 0.B
        io.PE_addrA(i) := Input_GB_baseAddress + vecA_addr
        io.PE_addrB(i) := Input_GB_baseAddress + vecB_addr
        io.PE_length(i) := vec_length
        io.PE_width(i) := vec_width
      }
      state := States.Idel

      io.Input_GB_write_en := 0.B
      io.Input_GB_read_en := 0.B
      io.Input_GB_addr := 0.U
      io.Input_GB_data_write := 0.U

      io.Output_GB_write_en := 0.B
      io.Output_GB_read_en := 0.B
      io.Output_GB_addr := 0.U
      io.DQ_out:= 0.U

    }
    is(States.Read_Output){
        io.Output_GB_write_en := 0.B
        io.Output_GB_read_en := 1.B
        io.Output_GB_addr := Output_GB_baseAddress + Output_addr + current_length * 2.U
        io.DQ_out:= io.Output_GB_data_read
        when(current_length + 4.U >= Output_length){
          current_length := 0.U
          state := States.Idel
        }
        .otherwise{
          current_length := current_length + 4.U
          state := States.Read_Output
        }
      

      io.Input_GB_write_en := 0.B
      io.Input_GB_read_en := 0.B
      io.Input_GB_addr := 0.U
      io.Input_GB_data_write := 0.U

      for(i <- 0 until 8){
        io.PE_en(i) := 0.B
        io.PE_mode(i) := 0.B
        io.PE_addrA(i) := 0.U
        io.PE_addrB(i) := 0.U
        io.PE_length(i) := 0.U
        io.PE_width(i) := 0.U
      }
    }
  }
}


// 测试例子
object NMP_controller extends App {
  val Width = 16 // 设置FP位宽
  emitVerilog(new ibex_core(Width), Array("--target-dir", "generated"))
}
